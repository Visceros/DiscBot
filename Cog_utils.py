from discord.ext import commands, tasks
from chests_rewards import usual_reward, gold_reward
import discord
import asyncio
import aiohttp
import io
import random
import datetime


class Listeners(commands.Cog):
    def __init__(self, bot: commands.Bot, db, sys_channel):
        self.bot = bot
        self.db = db
        self.sys_channel = sys_channel

# --------------------------- –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–∞—á–∞–ª–∞ –∏ –∫–æ–Ω—Ü–∞ –≤—Ä–µ–º–µ–Ω–∏ –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π ---------------------------
    @commands.Cog.listener()
    async def on_voice_state_update(self, member: discord.Member, before, after):
        db = self.db
        if str(member.status) not in ['invisible', 'dnd'] and not member.bot:
            if before.channel is None and after.channel is not None and not after.afk:
                gold = await db.fetchval(f'SELECT Gold from discord_users WHERE Id={member.id}')
                await db.execute(f'INSERT INTO LogTable (user_id, login, gold) VALUES ($1, $2, $3)', member.id, datetime.datetime.now().replace(microsecond=0), gold)
                #test = await db.fetchval("SELECT login::timestamp AT TIME ZONE 'GMT' from LogTable ORDER BY login DESC LIMIT 1")
                #print('added value Login:', test)
            elif before.channel is not None and after.channel is None:
                gold = await db.fetchval(f'SELECT Gold from discord_users WHERE id={member.id}')
                await db.execute(f"UPDATE LogTable SET Logoff='{datetime.datetime.now().replace(microsecond=0)}'::timestamptz, Gold={gold} WHERE Logoff IS NULL AND User_id={member.id}")
                #test = await db.fetchval("SELECT logoff::timestamptz ::timestamp AT TIME ZONE 'GMT' from LogTable ORDER BY logoff DESC LIMIT 1")
                #print('added value Logoff:', test)

    @commands.Cog.listener()
    async def if_one_in_voice(self, member: discord.Member, before, after):
        db = self.db
        sys_channel = self.sys_channel
        channel_groups_to_account_contain = ['party', '–ø–∞—Ç–∏', '—Å–≤—è–∑—å', 'voice']
        if any(item in before.channel.name.lower() for item in channel_groups_to_account_contain):
            if not member.voice.self_mute and not member.voice.mute:
                if len(before.channel.members) >= 2 and len(after.channel.members) == 1:
                    await asyncio.sleep(180)
                    if len(after.channel.members) == 1 and after.channel.members[0] == member:
                        await member.move_to(member.guild.afk_channel)
                        user_warns = await db.fetchval(f'SELECT Warns from discord_users WHERE Id={member.id}')
                        user_warns += 1
                        await db.execute(f"UPDATE LogTable SET Warns='{user_warns}' WHERE Id={member.id}")
                        await member.dm_channel.send('–í—ã –±—ã–ª–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω—ã –≤ AFK –∫–æ–º–Ω–∞—Ç—É, —Ç.–∫. —Å–∏–¥–µ–ª–∏ –≤ –æ–±—â–∏—Ö –∫–æ–º–Ω–∞—Ç–∞—Ö —Å '
                                                     '–≤–∫–ª—é—á–µ–Ω–Ω—ã–º –º–∏–∫—Ä–æ—Ñ–æ–Ω–æ–º, —á—Ç–æ –Ω–∞—Ä—É—à–∞–µ—Ç –ø—É–Ω–∫—Ç –æ–±—â–∏—Ö –ø—Ä–∞–≤–∏–ª —Å–µ—Ä–≤–µ—Ä–∞ –ø–æ–¥ ‚Ññ2.')
                        print('sent warn message to ', member.display_name)
                        await sys_channel.send(
                            f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {member.display_name} –ø–æ–ª—É—á–∏–ª –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –∑–∞ –Ω–∞—Ä—É—à–µ–Ω–∏–µ –ø—É–Ω–∫—Ç–∞ –ø—Ä–∞–≤–∏–ª —Å–µ—Ä–≤–µ—Ä–∞ ‚Ññ2 (–Ω–∞–∫—Ä—É—Ç–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏')
                    else:
                        pass
                elif len(before.channel.members) == 0 and len(after.channel.members) == 1:
                    await asyncio.sleep(180)
                    if len(after.channel.members) == 1 and after.channel.members[0] == member:
                        await member.move_to(member.guild.afk_channel)
                        user_warns = await db.fetchval(f'SELECT Warns from discord_users WHERE Id={member.id}')
                        user_warns += 1
                        await db.execute(f"UPDATE LogTable SET Warns='{user_warns}'")
                        await member.dm_channel.send('–í—ã –±—ã–ª–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω—ã –≤ AFK –∫–æ–º–Ω–∞—Ç—É, —Ç.–∫. —Å–∏–¥–µ–ª–∏ –≤ –æ–±—â–∏—Ö –∫–æ–º–Ω–∞—Ç–∞—Ö —Å '
                                                     '–≤–∫–ª—é—á–µ–Ω–Ω—ã–º –º–∏–∫—Ä–æ—Ñ–æ–Ω–æ–º, —á—Ç–æ –Ω–∞—Ä—É—à–∞–µ—Ç –ø—É–Ω–∫—Ç –æ–±—â–∏—Ö –ø—Ä–∞–≤–∏–ª —Å–µ—Ä–≤–µ—Ä–∞ –ø–æ–¥ ‚Ññ2.')
                        await sys_channel.send(
                            f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {member.display_name} –ø–æ–ª—É—á–∏–ª –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –∑–∞ –Ω–∞—Ä—É—à–µ–Ω–∏–µ –ø—É–Ω–∫—Ç–∞ –ø—Ä–∞–≤–∏–ª —Å–µ—Ä–≤–µ—Ä–∞ ‚Ññ2 (–Ω–∞–∫—Ä—É—Ç–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏')
                    else:
                        pass
            if len(before.channel.members) >= 2 and len(after.channel.members) == 1:
                await asyncio.sleep(180)
                if len(after.channel.members) == 1 and after.channel.members[0] == member:
                    await member.move_to(member.guild.afk_channel)
                    #user_warns = await db.fetchval(f'SELECT Warns from discord_users WHERE Id={member.id}')
                    #user_warns += 1
                    #await db.execute(f"UPDATE LogTable SET Warns='{user_warns}'")
                    #await member.dm_channel.send('–í—ã –±—ã–ª–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω—ã –≤ AFK –∫–æ–º–Ω–∞—Ç—É, —Ç.–∫. —Å–∏–¥–µ–ª–∏ –≤ –æ–±—â–∏—Ö –∫–æ–º–Ω–∞—Ç–∞—Ö —Å '
                    #                             '–≤–∫–ª—é—á–µ–Ω–Ω—ã–º –º–∏–∫—Ä–æ—Ñ–æ–Ω–æ–º, —á—Ç–æ –Ω–∞—Ä—É—à–∞–µ—Ç –ø—É–Ω–∫—Ç –æ–±—â–∏—Ö –ø—Ä–∞–≤–∏–ª —Å–µ—Ä–≤–µ—Ä–∞ –ø–æ–¥ ‚Ññ2.')
                    #await sys_channel.send(
                    #    f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {member.display_name} –ø–æ–ª—É—á–∏–ª –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –∑–∞ –Ω–∞—Ä—É—à–µ–Ω–∏–µ –ø—É–Ω–∫—Ç–∞ –ø—Ä–∞–≤–∏–ª —Å–µ—Ä–≤–µ—Ä–∞ ‚Ññ2 (–Ω–∞–∫—Ä—É—Ç–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏')
                else:
                    pass
            elif len(before.channel.members) == 0 and len(after.channel.members) == 1:
                await asyncio.sleep(180)
                if len(after.channel.members) == 1 and after.channel.members[0] == member:
                    await member.move_to(member.guild.afk_channel)
                    #user_warns = await db.fetchval(f'SELECT Warns from discord_users WHERE Id={member.id}')
                    #user_warns += 1
                    #await db.execute(f"UPDATE LogTable SET Warns='{user_warns}'")
                    #await member.dm_channel.send('–í—ã –±—ã–ª–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω—ã –≤ AFK –∫–æ–º–Ω–∞—Ç—É, —Ç.–∫. —Å–∏–¥–µ–ª–∏ –≤ –æ–±—â–∏—Ö –∫–æ–º–Ω–∞—Ç–∞—Ö —Å '
                    #                             '–≤–∫–ª—é—á–µ–Ω–Ω—ã–º –º–∏–∫—Ä–æ—Ñ–æ–Ω–æ–º, —á—Ç–æ –Ω–∞—Ä—É—à–∞–µ—Ç –ø—É–Ω–∫—Ç –æ–±—â–∏—Ö –ø—Ä–∞–≤–∏–ª —Å–µ—Ä–≤–µ—Ä–∞ –ø–æ–¥ ‚Ññ2.')
                    #await sys_channel.send(
                    #    f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {member.display_name} –ø–æ–ª—É—á–∏–ª –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –∑–∞ –Ω–∞—Ä—É—à–µ–Ω–∏–µ –ø—É–Ω–∫—Ç–∞ –ø—Ä–∞–≤–∏–ª —Å–µ—Ä–≤–µ—Ä–∞ ‚Ññ2 (–Ω–∞–∫—Ä—É—Ç–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏')
                else:
                    pass


class Games(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    # ------------- –ò–ì–†–ê –°–£–ù–î–£–ß–ö–ò -----------
    @commands.command()
    async def chest(self, ctx):
        reactions = ['1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£', '4Ô∏è‚É£', '5Ô∏è‚É£', '6Ô∏è‚É£']
        author = ctx.message.author
        channel = ctx.message.channel
        await ctx.message.delete()
        # Check if it's the right channel to write to and if user have relevant role
        if '—Å—É–Ω–¥—É—á–∫–∏' in channel.name.lower() or '–∫–∞–∑–∏–Ω–æ' in channel.name.lower():
            pass
        else:
            return await ctx.send('```Error! –ò–∑–≤–∏–Ω–∏—Ç–µ, —ç—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–º –∫–∞–Ω–∞–ª–µ.```')
        is_eligible = False
        if 'administrator' in ctx.message.author.guild_permissions:
            is_eligible = True
        if not is_eligible:
            return await ctx.send(f'```Error! –ò–∑–≤–∏–Ω–∏—Ç–µ, –¥–æ—Å—Ç—É–ø –∏–º–µ—é—Ç —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã```')
        else:
            # IF all correct we head further
            await ctx.send('```yaml\n–†–µ—à–∏–ª–∏ –∏—Å–ø—ã—Ç–∞—Ç—å —É–¥–∞—á—É –∏ –≤—ã–∏–≥—Ä–∞—Ç—å –≥–ª–∞–≤–Ω—ã–π –ø—Ä–∏–∑? –û—Ç–ª–∏—á–Ω–æ! \n' +
                           '–í—ã–±–µ—Ä–∏—Ç–µ, –∫–∞–∫–æ–π –∏–∑ —à–µ—Å—Ç–∏ –ø—Ä–æ—Å—Ç—ã—Ö —Å—É–Ω–¥—É–∫–æ–≤ –æ—Ç–∫—Ä—ã–≤–∞–µ–º? –ù–∞–∂–º–∏—Ç–µ –Ω–∞ —Ü–∏—Ñ—Ä—É –æ—Ç 1 –¥–æ 6```')
            # begin pasting the picture with usual chests
            async with aiohttp.ClientSession() as session:
                async with session.get(
                        'https://cdn.discordapp.com/attachments/585041003967414272/647943159762124824/Untitled_-_6.png') as resp:
                    if resp.status != 200 and 301:
                        return await channel.send('Error! Could not get the file...')
                    data = io.BytesIO(await resp.read())
                    start_message = await channel.send(file=discord.File(data, 'Normal-chests.png'))
                    await session.close()
            # end of pasting the picture with usual chests
            for react in reactions:
                await start_message.add_reaction(react)

            def checkS(reaction, user):
                return str(reaction.emoji) in reactions and user.bot is not True

            def checkG(reaction, user):
                return str(reaction.emoji) in reactions[0:2] and user.bot is not True

            try:
                reaction, user = await self.bot.wait_for('reaction_add', timeout=180, check=checkS)
            except asyncio.TimeoutError:
                await ctx.send('```yaml\n–£–¥–∞—á–∞ –Ω–µ —Ç–µ—Ä–ø–∏—Ç –º–µ–¥–ª–∏—Ç–µ–ª—å–Ω—ã—Ö. –í—Ä–µ–º—è –≤—ã—à–ª–æ! üëé```')
            else:
                reward, pic = usual_reward()
                await channel.send(f'```yaml\n–°—É–Ω–¥—É–∫ —Å–æ —Å–∫—Ä–∏–ø–æ–º –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç—Å—è –∏... {reward}```')
                async with aiohttp.ClientSession() as session:
                    async with session.get(pic) as resp:
                        if resp.status != 200 and 301:
                            return await channel.send('Error! Could not get the file...')
                        data = io.BytesIO(await resp.read())
                        await channel.send(file=discord.File(data, 'reward.png'))
                if '–∑–æ–ª–æ—Ç–æ–π –∫–ª—é—á' in reward.lower():
                    await ctx.send(
                        '```fix\n–û–ì–û! –î–∞ —É –Ω–∞—Å —Å—á–∞—Å—Ç–ª–∏–≤—á–∏–∫! –ü—Ä–∏–Ω–∏–º–∞–π—Ç–µ –ø–æ–∑–¥—Ä–∞–≤–ª–µ–Ω–∏—è –∏ –≥–æ—Ç–æ–≤—å—Ç–µ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –∑–æ–ª–æ—Ç–æ–π —Å—É–Ω–¥—É–∫!```')
                    # Begin pasting the picture with Gold chests
                    async with aiohttp.ClientSession() as session:
                        async with session.get(
                                'https://cdn.discordapp.com/attachments/585041003967414272/647935813962694676/51d6848c09aba40c.png') as resp:
                            if resp.status != 200 and 301:
                                return await channel.send('Error! Could not get the file...')
                            data = io.BytesIO(await resp.read())
                            start_message = await channel.send(file=discord.File(data, 'Golden-chests.png'))
                            await session.close()
                    # End of pasting the picture with Gold chests
                    for react in reactions[0:3]:
                        await start_message.add_reaction(react)
                    try:
                        reaction, user = await self.bot.wait_for('reaction_add', timeout=180, check=checkG)
                    except asyncio.TimeoutError:
                        return await ctx.send('```fix\n–£–¥–∞—á–∞ –Ω–µ —Ç–µ—Ä–ø–∏—Ç –º–µ–¥–ª–∏—Ç–µ–ª—å–Ω—ã—Ö. –í—Ä–µ–º—è –≤—ã—à–ª–æ! üëé```')
                    else:
                        reward, pic = gold_reward()
                        await channel.send('```fix\n–í—ã –ø—Ä–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç–µ –ó–æ–ª–æ—Ç–æ–π –∫–ª—é—á –≤ –∑–∞–º–æ—á–Ω–æ–π —Å–∫–≤–∞–∂–∏–Ω–µ ' +
                                           f'–∏ –∫—Ä—ã—à–∫–∞ —Ç–∏—Ö–æ–Ω—å–∫–æ –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç—Å—è...\n{reward}```')
                        async with aiohttp.ClientSession() as session:
                            async with session.get(pic) as resp:
                                if resp.status != 200 and 301:
                                    return await channel.send('Error! Could not get the file...')
                                data = io.BytesIO(await resp.read())
                                await channel.send(file=discord.File(data, 'gold-reward.png'))

    # -------------- –ö–û–ù–ï–¶ –ò–ì–†–´ –°–£–ù–î–£–ß–ö–ò ------------------

    # ------------- –ò–ì–†–ê –ë–ò–ù–ì–û -----------
    @commands.command(pass_context=True)
    async def fortuna(self, ctx):
        await ctx.message.delete()
        bingo_numbers = ['üü¶1Ô∏è‚É£', 'üü¶2Ô∏è‚É£', 'üü¶3Ô∏è‚É£', 'üü¶4Ô∏è‚É£', 'üü¶5Ô∏è‚É£', 'üü¶6Ô∏è‚É£', 'üü¶7Ô∏è‚É£', 'üü¶8Ô∏è‚É£', 'üü¶9Ô∏è‚É£', '1Ô∏è‚É£0Ô∏è‚É£',
                         '1Ô∏è‚É£1Ô∏è‚É£', '1Ô∏è‚É£2Ô∏è‚É£',
                         '1Ô∏è‚É£3Ô∏è‚É£', '1Ô∏è‚É£4Ô∏è‚É£', '1Ô∏è‚É£5Ô∏è‚É£', '1Ô∏è‚É£6Ô∏è‚É£', '1Ô∏è‚É£7Ô∏è‚É£', '1Ô∏è‚É£8Ô∏è‚É£', '1Ô∏è‚É£9Ô∏è‚É£', '2Ô∏è‚É£0Ô∏è‚É£', '2Ô∏è‚É£1Ô∏è‚É£',
                         '2Ô∏è‚É£2Ô∏è‚É£', '2Ô∏è‚É£3Ô∏è‚É£', '2Ô∏è‚É£4Ô∏è‚É£', '2Ô∏è‚É£5Ô∏è‚É£', '2Ô∏è‚É£6Ô∏è‚É£']
        edit_msg = await ctx.send(random.choice(bingo_numbers))
        for i in range(3):
            await edit_msg.edit(content=random.choice(bingo_numbers))
            await asyncio.sleep(0.2)

    # ------------- –ö–û–ù–ï–¶ –ò–ì–†–´ –ë–ò–ù–ì–û -----------

    @commands.command(pass_context=True)
    async def bingo(self, ctx):
        await ctx.message.delete()
        prize = 0

        def makenums():
            nums = ""
            for _ in range(3):
                nums += str(random.randint(0, 9))
            return nums

        ed_msg = await ctx.send(makenums())
        # rules ---> ctx.send('```fix\n –∫–∞–∫–æ–≤—ã –ø—Ä–∞–≤–∏–ª–∞? ```')
        for i in range(3, 9):
            ed = makenums()
            await ed_msg.edit(content=ed, suppress=False)
            await asyncio.sleep(0.2)


class Utils(commands.Cog):
    pass

